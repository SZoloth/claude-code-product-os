AudoPaper • Codebase Context (for LLMs)

Scope: Summarizes repository goals, structure, public APIs, and key data types for quick reasoning and safe automation. Keep DRY; prefer high‑level clarity over duplication.

1) Command Goals (.claude/commands)
- 01_experiment_driven_development.md: Run small, logged experiments. Capture goal ➜ learnings ➜ surgical plan ➜ attempt ➜ outcome ➜ iterate.
- 02_generate_codebase_context.md: Produce this llms.txt with goals, APIs, connections, and concise conclusions.
- 03_analyze_github_issue.md: Read an issue, create a branch plan (impacts, tests, docs, perf, security, compat), and ask for approval before changes.
- 04_create_github_issue.md: Turn feature/bug ideas into well‑structured GitHub issues using repo conventions and best practices.
- 05_resolve_pr_comments.md: Systematically research ➜ plan ➜ implement ➜ verify all PR comments and requested changes.

2) Product Context (Audo)
- Goal: iOS SwiftUI app to search academic sources (PubMed first), save and manage papers, and control flows via voice.
- Architecture: SwiftUI app shell; Voice layer (recognition, commands, TTS, VAD, error handling); Search/API layer; Core Data persistence.
- Build: open Audo/Audo.xcodeproj (Xcode) or xcodebuild. Tests via XCTest.

3) High-Level Components
- App/UI: `AudoApp`, `ContentView` (placeholder UI).
- Voice: `VoiceManager`, `CommandProcessor`, `SpeechService`, `VoiceSettingsManager`, `VoiceActivityDetector`, `VoiceErrorHandler`, `VoiceFeedbackHandler`.
- Search/API: `SearchCoordinator`, `PubMedService`, `APIService`.
- Persistence/Models: `CoreDataStack`, `SavedItem` (ext), `Subscription` (ext), `PreviewData`, `DataMigrationManager`.
- Tests: `AudoTests` (Testing framework placeholder), `AudoUITests`.

4) Key Data Types (selected)
- SavedItem fields (inferred from usage): id: UUID, title: String, authors: String?, venue: String?, year: Int32, pmid: String?, doi: String?, abstractSnippet: String?, source: String, status: String, progress: Double, progressType: String?, progressValue: Int32?, personalNotes: String?, createdAt/updatedAt: Date? (typical).
- Subscription fields (inferred): id: UUID, type: String, value: String, personalShortcuts: [String], enabled: Bool, createdAt: Date, lastUsed: Date?
- PubMedPaper: pmid: String, title: String, authors: String, journal: String, year: Int, doi: String?, abstract: String?

5) Public APIs (functions, params, types) with concise purpose

App/UI
- AudoApp: main entry; creates `ContentView()` scene.
- ContentView: placeholder SwiftUI view.

Voice
- VoiceManager (ObservableObject, @MainActor)
  - requestSpeechRecognitionAuthorization() -> Void: Requests SFSpeech authorization and updates `authorizationStatus`.
  - canRecognizeSpeech: Bool: True if authorized and recognizer available.
  - startListening() throws -> Void: Configures AVAudioEngine + recognition task; streams audio buffers to SFSpeech.
  - stopListening() -> Void: Stops engine, clears recognition state.
  - speak(_ text: String, priority: SpeechPriority = .normal) -> Void: Speaks via AVSpeechSynthesizer with current settings and priority policy.
  - stopSpeaking() -> Void, pauseSpeaking() -> Void, continueSpeaking() -> Void: Synthesis controls.
  - detectVoiceActivity() -> Bool: Simple VAD placeholder (vol/rate check).
  - updateVoiceSettings(_ settings: VoiceSettings) -> Void; currentVoiceSettings: VoiceSettings.
  - Delegate callbacks: AVSpeechSynthesizerDelegate, SFSpeechRecognizerDelegate (updates `isSpeaking`, handles availability).
  - State: @Published isListening, isProcessing, isSpeaking, lastTranscription, recognitionError: VoiceError?, authorizationStatus.

- CommandProcessor (@MainActor)
  - init(voiceManager: VoiceManager)
  - processCommand(_ transcript: String) -> Void: Normalize ➜ parse ➜ execute or respond with help.
  - Private parse helpers:
    - extractSearchTerm(from: String) -> String?
    - extractNavigationDestination(from: String) -> NavigationDestination?
    - extractPlaybackAction(from: String) -> PlaybackAction?
    - extractControlAction(from: String) -> ControlAction?
    - extractSubscriptionInfo(from: String) -> (type: SubscriptionType, value: String)?
    - extractStatusInfo(from: String) -> String?
  - Private execute helpers:
    - executeSearchCommand(query: String) -> Void (delegates to SearchCoordinator.performSearch)
    - executeNavigationCommand(destination: NavigationDestination) -> Void (speaks; TODO hook UI nav)
    - executePlaybackCommand(action: PlaybackAction) -> Void (speaks and calls VoiceManager synthesis controls)
    - executeControlCommand(action: ControlAction) -> Void
    - executeSubscriptionCommand(type: SubscriptionType, value: String) -> Void (TODO persist)
    - executeStatusCommand(status: String) -> Void (TODO persist)
    - executeHelpCommand() -> Void (speaks help)

- SpeechService (ObservableObject, @MainActor)
  - speak(_ text: String, priority: SpeechPriority = .normal, type: SpeechType = .general, metadata: SpeechMetadata? = nil) -> Void: Enqueue and optionally interrupt based on priority.
  - stopSpeaking() -> Void, pauseSpeaking() -> Void, resumeSpeaking() -> Void, skipToNext() -> Void
  - updateAccessibilitySettings(_ settings: AccessibilitySpeechSettings) -> Void; currentSettings: AccessibilitySpeechSettings
  - Convenience: speakPaperTitle(_:), speakPaperAbstract(_:), speakNotification(_:), speakError(_:)
  - State: @Published isSpeaking, isPaused, currentUtterance: String?, speechProgress: Double, speechQueue: [SpeechItem]

- VoiceSettingsManager (ObservableObject, @MainActor)
  - loadSettings() -> Void, saveSettings() -> Void: Persist via UserDefaults (JSON encode/decode).
  - availableVoices: [AVSpeechSynthesisVoice]
  - getOptimalVoice(for: ContentType) -> AVSpeechSynthesisVoice?
  - validateSettings() -> [SettingsValidationIssue], fixValidationIssues() -> Void
  - exportSettings() -> Data?, importSettings(from: Data) throws -> Void
  - State: @Published speechSettings: SpeechSettings, recognitionSettings: RecognitionSettings, accessibilitySettings: AccessibilityVoiceSettings, personalizationSettings: PersonalizationSettings

- VoiceActivityDetector (ObservableObject, @MainActor)
  - startMonitoring() -> Void, stopMonitoring() -> Void
  - handleSpeechInterruption() -> Void, handleListeningInterruption() -> Void
  - updateVADSettings(_ settings: VoiceActivitySettings) -> Void; currentVADSettings: VoiceActivitySettings
  - getVoiceActivityStatistics(for: TimeInterval = 300) -> VoiceActivityStatistics
  - performCalibration(duration: TimeInterval = 5.0) async -> Void
  - testVADResponsiveness() -> VADTestResults
  - State: @Published isVoiceActive: Bool, currentVolume: Float, backgroundNoise: Float, voiceActivityHistory: [VoiceActivityEvent]

- VoiceErrorHandler (ObservableObject, @MainActor)
  - handleError(_ error: VoiceError, context: String? = nil, retry: (() -> Void)? = nil) -> Void
  - markErrorAsRecovered(_ error: VoiceError) -> Void, clearErrorHistory() -> Void
  - errorStatistics: VoiceErrorStatistics
  - Internals: network monitoring, recovery strategies (retry, backoff, fallback modes, audio reconfig), NotificationCenter hooks.

- VoiceFeedbackHandler (VoiceFeedbackDelegate, @MainActor)
  - provideFeedback(_ message: String) async -> Void (speaks via VoiceManager)

Search/API
- SearchCoordinator (ObservableObject, @MainActor)
  - performSearch(query: String) async -> Void: Feedback ➜ PubMedService.search ➜ save ➜ feedback on results (and speak first title).
  - voiceFeedbackDelegate: VoiceFeedbackDelegate?

- PubMedService : APIService (@MainActor)
  - search(query: String) async throws -> [PubMedPaper]
  - savePapers(_ papers: [PubMedPaper], to context: NSManagedObjectContext) async -> Void
  - Private: searchForIDs(query: String) async throws -> [String]; fetchPaperDetails(ids: [String]) async throws -> [PubMedPaper]

- APIService (ObservableObject, @MainActor)
  - performRequest<T: Codable>(_ request: URLRequest, responseType: T.Type) async throws -> T
  - APIError: invalidURL, invalidResponse, httpError(Int), decodingError(Error), networkUnavailable

Persistence/Models
- CoreDataStack (ObservableObject)
  - shared: CoreDataStack (singleton)
  - persistentContainer: NSPersistentContainer
  - viewContext: NSManagedObjectContext; backgroundContext() -> NSManagedObjectContext
  - save() -> Void; saveBackground(_ context: NSManagedObjectContext) -> Void
  - batchDelete<T: NSManagedObject>(fetchRequest: NSFetchRequest<T>) throws -> Void
  - clearOldSearchCache() -> Void; validateDataIntegrity() -> Void
  - getDatabaseStats() -> DatabaseStats
  - DEBUG: deleteAllData() -> Void; createSampleData() -> Void
  - Migration helpers in extension: performMigrationIfNeeded() -> Void; `preview` stack for SwiftUI previews

- SavedItem (extension)
  - enum Status: String { new, shortlist, later, in_progress, completed, dismissed }
  - enum Source: String { PubMed, OpenAlex }
  - enum ProgressType: String { character_index, time_seconds, section_number }
  - create(in: NSManagedObjectContext, title: String, authors: String? = nil, venue: String? = nil, year: Int = 0, pmid: String? = nil, doi: String? = nil, abstractSnippet: String? = nil, source: Source = .pubmed) -> SavedItem

- Subscription (extension)
  - enum SubscriptionType: String { keyword, author, journal }
  - create(in: NSManagedObjectContext, type: SubscriptionType, value: String, shortcuts: [String] = []) -> Subscription

- PreviewData
  - shared, context, creates sample SavedItem/Subscription entries for previews only.

- DataMigrationManager
  - requiresMigration(at storeURL: URL) -> Bool
  - migrate/backup/validate/restore helpers (scaffolded; example comments included)

Tests
- AudoTests.swift: Placeholder example using `Testing` framework (not XCTest).
- AudoUITests: Launch, baseline UI tests.

6) Data Flow (happy path)
- VoiceManager captures audio ➜ SFSpeech transcribes ➜ CommandProcessor parses ➜ SearchCoordinator performs search ➜ PubMedService fetches via APIService ➜ results mapped to `SavedItem` via CoreDataStack ➜ VoiceFeedbackHandler speaks updates.

7) Notes on Networking & Security
- Use `URLSession.shared` in APIService; basic error mapping; JSONDecoder default.
- Avoid committing secrets; prefer system config. External links opened via SafariViewController when added.

8) Code Style and Accessibility
- Swift 5+, SwiftUI, 2‑space indentation; PascalCase types, camelCase members. Small views + view models.
- Accessibility: respectful speech defaults, rotor landmarks (to add as UI grows), clear VoiceOver voices.
- Logging: OSLog categories per component (CoreData, Voice*, API*…).

9) Included Data Formats
- PubMed E-utilities: JSON esearch/esummary; mapped into lightweight `PubMedPaper` before persistence.
- Core Data string enums for statuses and types to ease migration.
- Settings persisted via JSON in UserDefaults (VoiceSettingsManager).

10) ASCII Map (connections)

   +-------------------+        +-------------------+
   |     AudoApp      |        |    ContentView    |
   +---------+---------+        +---------+---------+
             |                             |
             v                             v
      +------+-------------------------------+
      |            VoiceManager              |
      |  (AVAudioEngine, SFSpeech, AVSpeech) |
      +------+------------------+------------+
             |                  |
             v                  v
   +---------+---------+   +----+------------------+
   |   CommandProcessor |   |   SpeechService      |
   +----+------+--------+   +----------------------+
        |      |                    ^
   parse|      |execute             |
        v      v                    |
   +----+------+--------+           |
   |  SearchCoordinator |-----------+
   +----+------+--------+
        |      |
        v      v
 +------+--+  +----------------+
 |PubMedSvc|->|  APIService    |
 +----+----+  +----------------+
      |
      v
 +----+------------------------------+
 |           CoreDataStack           |
 |  SavedItem, Subscription (ext)    |
 +----+------------------------------+
      ^
      |
 +----+------------------------------+
 |   VoiceSettingsMgr / VAD / Errors |
 |   (UserDefaults, timers, notify)  |
 +-----------------------------------+

11) Conclusions (veteran dev perspective)
- Structure: Clear separation of concerns (Voice, Search/API, Persistence). VoiceManager is the façade for recognition + synthesis, delegating to focused helpers; SearchCoordinator centralizes domain orchestration.
- Cohesion: Good single-responsibility classes; room to formalize protocols for voice command handling and navigation.
- Error handling: Strong start with VoiceErrorHandler; align APIService with similar recovery/fallback patterns (reachability, retries, backoff).
- Testing: Stubs exist; prioritize unit tests for CommandProcessor parsing, PubMedService mapping, CoreDataStack batch ops, and VoiceErrorHandler strategies.
- Performance: AVAudio + speech work is on main actor; validate thread hops (Combine/async) to keep UI responsive; avoid heavy work on main.
- Extensibility: Add OpenAlex/Unpaywall services behind a protocol (`SearchBackend`) to support multi-source search and ranking.
- Migration/Models: Enums stored as strings ease migration; add .xcdatamodel and verify mapping models before production.
- Style: Follows Swift API Design Guidelines, OSLog per subsystem, 2-space indentation, concise method scopes.

